import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.lang.reflect.Array;
import java.lang.instrument.Instrumentation;
import java.lang.Object;
public class ArrayBasedSpreadSheet {
	public Object [][] data;
	public ArrayBasedSpreadSheet (int rows, int columns) {
		this.data = new Object [columns][rows]; //Must be columns and then rows - normally it's the reverse
	}
	public String getSpreadSheetAsCSV(boolean showFormulas) {
		if (showFormulas == false) { //If the user writes false, show the values generated by calculating the formulas.			
			String returnString = ""; //Step #1: Return column headers
			char charCounter = 'A';
			for (int i = 0; i < this.data.length - 1; i++) {
				returnString = returnString + charCounter++ + ",";
				if (1+i == this.data.length - 1) { //Last letter of the row
					returnString = returnString + charCounter + "\n"; //Ends line with a "\n" and without a ","
				}
			}			
			for (int i = 0; i < this.data[0].length; i++) {	//Step #2: Return the actual data - Rows
				char cellLabel = 'A';
				for (int j = 0; j < this.data.length - 1; j++) { //Columns
					int fakeRow = i + 1;
					returnString = returnString + (getValue (cellLabel, fakeRow) + ","); //Using getValue because we want to calculate the formulas
					if (1+j == this.data.length - 1) { //Last column of the row
						char tempCell = cellLabel;
						returnString = returnString + (getValue (++tempCell, fakeRow) + "\n"); //Ends line with a "\n" and without a ","
					} 
					cellLabel++;
				} 
			} return returnString;
		} else { //If true, show the raw cell formulas					
			String returnString = ""; //Step #1: Return column headers
			char charCounter = 'A';
			for (int i = 0; i < this.data.length - 1; i++) { 
				returnString = returnString + charCounter++ + ",";
				if (1+i == this.data.length - 1) { //Last letter of the row
					returnString = returnString + charCounter + "\n"; //Ends line with a "\n" and without a ","
				}
			}			
			for (int i = 0; i < this.data[0].length; i++) { //Step #2: Return the actual data - Rows
				for (int j = 0; j < this.data.length - 1; j++) { //Columns
					if (this.data[j][i] == null) { //If it's null, then replace it with 0.0 - this must be checked manually because can't use getValue
						returnString = returnString + 0.0 + ",";
					} else {
						returnString = returnString + String.valueOf(this.data[j][i]) + ","; //Otherwise, return the string value of the cell, even if it's a formula
					}
					if (1+j == this.data.length - 1) { //Last column of the row
						if (this.data[j + 1][i] == null) {
							returnString = returnString + 0.0 + "\n";  //Ends line with "\n" and without a ","
						} else {
							returnString = returnString + String.valueOf(this.data[j + 1][i]) + "\n";  //Ends line with "\n" and without a ","
						}
					}
				}
			} return returnString;
		}
	}
	public void setValue(char column, int row, String value) {
		int realRow = row - 1; 
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1; 
		if (columnLength > this.data.length) { //Step #1: Check if the column length is too long - if it is, expand the spreadSheet's column length - Using columnLength
			expandColumnRange (column);		
		}
		if (row > this.data[0].length) { //Step #2: Check if the cell row length is too long - if it is expand the spreadSheet's row length - Using row length
			Object [][] expandRowRange = new Object [this.data.length][row]; 
			for (int i = 0; i < this.data[0].length; i++) { //row
				for (int j = 0; j < this.data.length; j++) { //column
					expandRowRange[j][i] = this.data[j][i]; //Saving the data
				}
			}
			this.data = expandRowRange;
		}
		try { //Step #3: Double or a cell formula? The reason this step is critical is to check if their is a formula and if there is to check if the formula's cells are out of the current bounds. 
			double isValidDouble = Double.parseDouble (value); //If double, then set it just set the value
			this.data[realColumn][realRow] = isValidDouble;  
			return;
		} catch (NumberFormatException e) { //Set Formula but do not perform it!
			String [] formula = value.split(" "); //Check if the formula's cells are beyond the current bounds
			char firstColumnLabel = value.charAt(0); //Part A: 1st Cell's Column
			int firstColumnNumber = 0;
			for (char counter = 'A'; counter <= firstColumnLabel; counter++) {
				firstColumnNumber++;
			}
			if (firstColumnNumber > this.data.length) {  
				expandColumnRange (firstColumnLabel);		
			}
			int firstRowLabel = Integer.parseInt ((formula[0].substring(1))); //Part B: 1st Cell's Row
			if (firstRowLabel > this.data[0].length) { 
				Object [][] expandRowRange1 = new Object [this.data.length][firstRowLabel]; 
				for (int i = 0; i < this.data[0].length; i++) { //row
					for (int j = 0; j < this.data.length; j++) { //column
						expandRowRange1[j][i] = this.data[j][i]; //Saving the data
					}
				}
				this.data = expandRowRange1;
			}
			char secondColumnLabel = formula[2].charAt(0); //Part C: 2nd Cell's Column
			int secondColumnNumber = 0;
			for (char counter = 'A'; counter <= secondColumnLabel; counter++) {
				secondColumnNumber++;
			}
			if (secondColumnNumber > this.data.length) {  
				expandColumnRange (secondColumnLabel);		
			}
			int secRowLabel = Integer.parseInt ((formula[2].substring(1))); //Part D: 2nd Cell's Row
			if (secRowLabel > this.data[0].length) { 
				Object [][] expandRowRange2 = new Object [this.data.length][secRowLabel]; 
				for (int i = 0; i < this.data[0].length; i++) { //row
					for (int j = 0; j < this.data.length; j++) { //column
						expandRowRange2[j][i] = this.data[j][i]; //Saving the data
					}
				}
				this.data = expandRowRange2;
			}
			this.data[realColumn][realRow] = value; //Set the formula to the cell - Do not calculate it!
			return;
		}
	}
	public Object[][] getCopyOfData() {
		Object [][] getCopyOfData = new Object [this.data.length][this.data[0].length];
		for (int i = 0; i < this.data[0].length; i++) { //Rows 
			for (int j = 0; j < this.data.length; j++) { //Columns
				getCopyOfData[j][i] = this.data [j][i];
			}
		}
		return getCopyOfData;
	}		
	public void expandColumnRange(char column) { //Expand the spreadsheet to the given column.
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		if (columnLength > this.data.length) { //Only run if the columnLength is being expanded not shortened
			Object [][] expandColumnRange = new Object [columnLength][this.data[0].length];
			for (int i = 0; i < this.data[0].length; i++) { //rows 
				for (int j = 0; j < this.data.length; j++) { //columns
					expandColumnRange[j][i] = this.data[j][i];
				}
			}
			this.data = expandColumnRange;
		}
	}
	public Object[] getCopyOfColumnThroughRow(char c, int throughRow) { //Returns a copy of a given column up to and including the given row - If throughRow is larger than the current height of the column, all the values in the rows past the current column height must be returned as null.
		int columnLength = 0;
		for (char counter = 'A'; counter <= c; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		Object [] getCopyOfColumnThroughRow = new Object [throughRow];		
		for (int i = 0; i < throughRow; i++) {
			getCopyOfColumnThroughRow[i] = this.data[realColumn][i];
			if (i == this.data[realColumn].length - 1) {
				return getCopyOfColumnThroughRow;
			}
		} return getCopyOfColumnThroughRow;
	}
	public double getValue(char column, int row) {
		int realRow = row - 1;
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		if (this.data[realColumn][realRow] == null) { //Step #1: If the value is null, change it to 0.0
				double returnZero = 0;
				return returnZero;
		} else {
			try { //Step #2: isValidDouble
				double isValidDouble = Double.parseDouble (String.valueOf(this.data[realColumn][realRow]));
				return isValidDouble;
			} catch (NumberFormatException e) { //Step #3: If it's not null or a validDouble, then send the INPUT values to evaluateFormula
				return evaluateFormula (column, row);
			}
		}
	}
	public double getValue(String cell) {		
		char userColumnLabel = cell.charAt(0);
		int userRowLabel =  Integer.parseInt ((cell.substring(1))); 
		int realRow = userRowLabel - 1; 
		int columnLength = 0;
		for (char counter = 'A'; counter <= userColumnLabel; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		if (this.data[realColumn][realRow] == null) { //Step #1: If the value is null, change it to 0.0
				double returnZero = 0;
				return returnZero;
		} else {
			try { //Step #2: isValidDouble
				double isValidDouble = Double.parseDouble (String.valueOf(this.data[realColumn][realRow]));
				return isValidDouble;
			} catch (NumberFormatException e) { //Step #3: If it's not null or a validDouble, then send the INPUT values to evaluateFormula
				return evaluateFormula(userColumnLabel, userRowLabel);
			}
		}
	}
	public double evaluateFormula(char column, int row) { //return the numeric value produced by evaluating the formula stored in the given cell 
		int realRow = row - 1; 
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		String cell = String.valueOf(this.data[realColumn][realRow]);
		if (cell.length () < 7) { //Make sure that there is an equation - we are not responsible for equations like (C4 + 1)
			throw new IllegalStateException (); //throws if the cell does not contain a formula, throw an IllegalStateException
		}
		String [] formula = cell.split(" "); //Step #1: Get the values in each of the cells.
		char columnLabel = cell.charAt(0); //1st Cell
		int rowLabel =  Integer.parseInt ((formula[0].substring(1))); //What if the row is more than 9? 
		char secColumnLabel = formula[2].charAt(0); //2nd Cell
		int secRowLabel =  Integer.parseInt ((formula[2].substring(1)));
		String equationSymbol = formula[1].substring(0);
		double firstCellValue = getValue (columnLabel, rowLabel); //Step #2: check if there is another formula in either of the individual cells
		double secondCellValue = getValue (secColumnLabel, secRowLabel);
		switch(equationSymbol) { //Last Step: Perform the equation
			case "+":
				return (firstCellValue + secondCellValue);
			case "-":
				return (firstCellValue - secondCellValue);
			case "*":
				return (firstCellValue * secondCellValue);
			case "/":
				return (firstCellValue / secondCellValue);
			default:
				throw new IllegalStateException (); //if the cell does not contain a formula, throw an IllegalStateException
		}
	}
}