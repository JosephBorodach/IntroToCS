import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.lang.reflect.Array;
import java.lang.instrument.Instrumentation;
import java.lang.Object; 
public class CellSpreadSheet implements CellProvider { //"CellSpreadSheet must implement the CellProvider interface"
	public Cell [][] data;
	public CellSpreadSheet (int columns, int rows) {
		this.data = new Cell [columns][rows]; //Must be columns and then rows - normally it's the reverse
	}
	public String getSpreadSheetAsCSV(boolean showFormulas) {
		if (showFormulas == false) { //If the user writes false, show the values generated by calculating the formulas.			
			String returnString = ""; //Step #1: Return column headers
			char charCounter = 'A';
			for (int i = 0; i < this.data.length - 1; i++) {
				returnString = returnString + charCounter++ + ",";
				if (1+i == this.data.length - 1) { //Last letter of the row
					returnString = returnString + charCounter + "\n"; //Ends line with a "\n" and without a ","
				}
			}			
			for (int i = 0; i < this.data[0].length; i++) {	//Step #2: Return the actual data - //Rows
				char cellLabel = 'A';
				for (int j = 0; j < this.data.length - 1; j++) { //Columns
					int fakeRow = i + 1;
					returnString = returnString + (getValue (cellLabel, fakeRow) + ","); //Using getValue because we want to calculate the formulas
					if (j == this.data.length - 2) { //Last column of the row
						char tempCell = cellLabel;
						returnString = returnString + (getValue (++tempCell, fakeRow) + "\n"); //Ends line with a "\n" and without a ","
					} 
					cellLabel++;
				} 
			} return returnString;
		} else { //If true, show the raw cell formulas						
			String returnString = ""; //Step #1: Return column headers
			char charCounter = 'A';
			for (int i = 0; i < this.data.length - 1; i++) {
				returnString = returnString + charCounter++ + ",";
				if (1+i == this.data.length - 1) { //Last letter of the row
					returnString = returnString + charCounter + "\n"; //Ends line with a "\n" and without a ","
				}
			}			
			for (int i = 0; i < this.data[0].length; i++) { //Step #2: Return the actual data - Rows
				for (int j = 0; j < this.data.length - 1; j++) { //Columns
					if (this.data[j][i] == null) { //If it's null, then replace it with 0.0 - this must be checked manually because can't use getValue
						returnString = returnString + 0.0 + ",";
					} else {
						returnString = returnString + this.data[j][i].getStringValue() + ","; //Otherwise, return the string value of the cell, even if it's a formula
					}
					if (1+j == this.data.length - 1) { //Last column of the row
						if (this.data[j + 1][i] == null) {
							returnString = returnString + 0.0 + "\n";  //Ends line with "\n" and without a ","
						} else {
							returnString = returnString + this.data[j + 1][i].getStringValue() + "\n";  //Ends line with "\n" and without a ","
						}
					}
				}
			} return returnString;
		}
	}
	public void setValue (char column, int row, String value) {
		int realRow = row - 1; //row is the user row which begins at 1; realRow, Java's row, begins at 0 and therefore is = to (row - 1)
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1; //columnLength is the user's column, which begins at A and is equated to 1; realColumn begins at 0 and is therefore = to (column - 1).
		if (columnLength > this.data.length) { //Step #1: Check if the column length is too long - if it is, expand the spreadSheet's column length - Using columnLength
			expandColumnRange (column);		
		}
		if (row > this.data[0].length) { //Step #2: Check if the cell row length is too long - if it is expand the spreadSheet's row length - Using row length
			Cell [][] expandRowRange = new Cell [this.data.length][row]; //Again, use row
			for (int i = 0; i < this.data[0].length; i++) { //row
				for (int j = 0; j < this.data.length; j++) { //column
					expandRowRange[j][i] = this.data[j][i]; //Saving the data
				}
			}
			this.data = expandRowRange;
		}		
		try { //Step #3: Double or a cell formula? The reason this step is critical is to check if their is a formula and if there is to check if the formula's cells are out of the current bounds 
			Double.parseDouble (value); If double, then set it just set the value
			Cell cell = new DoubleCell (Double.valueOf(value));
			this.data[realColumn][realRow] = cell;
			return;
		} catch (NumberFormatException e) { //Cells that contain formulas!
			String [] formula = value.split(" "); //Step #4: Check if the formula's cells are beyond the current bounds
			char firstColumnLabel = value.charAt(0); //Part A: 1st Cell's Column
			int firstColumnNumber = 0;
			for (char counter = 'A'; counter <= firstColumnLabel; counter++) {
				firstColumnNumber++;
			}
			if (firstColumnNumber > this.data.length) {  
				expandColumnRange (firstColumnLabel);		
			}
			int firstRowLabel = Integer.parseInt ((formula[0].substring(1))); //Part B: 1st Cell's Row
			if (firstRowLabel > this.data[0].length) { 
				Cell [][] expandFirstRowRange = new Cell [this.data.length][firstRowLabel]; 
				for (int i = 0; i < this.data[0].length; i++) { //row
					for (int j = 0; j < this.data.length; j++) { //column
						if (this.data[j][i] instanceof DoubleCell) {
							expandFirstRowRange[j][i] = new DoubleCell (this.data[j][i].getNumericValue());
						} else if (this.data[j][i] instanceof FormulaCell) {
							expandFirstRowRange[j][i] = new FormulaCell (this.data[j][i].getStringValue(), this);
						}
					}
				}
				this.data = expandFirstRowRange;
			}
			char secondColumnLabel = formula[2].charAt(0); //Part C: 2nd Cell's Column
			int secondColumnNumber = 0;
			for (char counter = 'A'; counter <= secondColumnLabel; counter++) {
				secondColumnNumber++;
			}
			if (secondColumnNumber > this.data.length) {  
				expandColumnRange (secondColumnLabel);		
			}
			int secRowLabel = Integer.parseInt ((formula[2].substring(1))); //Part D: 2nd Cell's Row
			if (secRowLabel > this.data[0].length) { 
				Cell [][] expandSecondRowRange = new Cell [this.data.length][secRowLabel]; 
				for (int i = 0; i < this.data[0].length; i++) { //row
					for (int j = 0; j < this.data.length; j++) { //column
						if (this.data[j][i] instanceof DoubleCell) {
							expandSecondRowRange[j][i] = new DoubleCell (this.data[j][i].getNumericValue());
						} else if (this.data[j][i] instanceof FormulaCell) {
							expandSecondRowRange[j][i] = new FormulaCell (this.data[j][i].getStringValue(), this);
						}
					}
				}
				this.data = expandSecondRowRange;
			}
			Cell cell = new FormulaCell (value, this); //Step #5: Set the formula to the cell, but do not perform the formula - The second parameter gives access to the entire CellSpreadSheet --> it should be an instance of the CellSpreadSheet Class
			this.data[realColumn][realRow] = cell;
			return;
		}
	}
	public Cell[][] getCopyOfData() {
		Cell [][] getCopyOfData = new Cell [this.data.length][this.data[0].length];
		for (int i = 0; i < this.data[0].length; i++) { //Rows 
			for (int j = 0; j < this.data.length; j++) { //Columns
				if (this.data[j][i] instanceof DoubleCell) {
					getCopyOfData[j][i] = new DoubleCell (this.data[j][i].getNumericValue());
				} else if (this.data[j][i] instanceof FormulaCell) {
					getCopyOfData[j][i] = new FormulaCell (this.data[j][i].getStringValue(), this);
				}
			}
		} return getCopyOfData;
	}
	public void expandColumnRange(char column) { //Expand the spreadsheet to the given column.
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		if (columnLength > this.data.length) { //Only run if the columnLength is being expanded not shortened
			Cell [][] expandColumnRange = new Cell [columnLength][this.data[0].length];
			for (int i = 0; i < this.data[0].length; i++) { //rows 
				for (int j = 0; j < this.data.length; j++) { //columns
					if (this.data[j][i] instanceof DoubleCell) {
						expandColumnRange[j][i] = new DoubleCell (this.data[j][i].getNumericValue());
					} else if (this.data[j][i] instanceof FormulaCell) {
						expandColumnRange[j][i] = new FormulaCell (this.data[j][i].getStringValue(), this);
					}								
				}
			}
			this.data = expandColumnRange;
		}
	}
	public Cell[] getCopyOfColumnThroughRow(char c, int throughRow) { //If throughRow is larger than the current height of the column, all the values in the rows past the current column height must be returned as null. - Returns a copy of a given column up to and including the given row.
		int columnLength = 0;
		for (char counter = 'A'; counter <= c; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		Cell [] getCopyOfColumnThroughRow = new Cell [throughRow]; 	
		for (int i = 0; i < throughRow; i++) {
			if (this.data[realColumn][i] instanceof DoubleCell) {
				getCopyOfColumnThroughRow[i] = new DoubleCell (this.data[realColumn][i].getNumericValue());
			} else if (this.data[realColumn][i] instanceof FormulaCell) {
				getCopyOfColumnThroughRow[i] = new FormulaCell (this.data[realColumn][i].getStringValue(), this);
			}			
			if (i == this.data[realColumn].length - 1) {
				return getCopyOfColumnThroughRow;
			}
		} return getCopyOfColumnThroughRow;
	}
	public double getValue(char column, int row) {
		int realRow = row - 1; //row is the user row which begins at 1; realRow, Java's row, begins at 0 and therefore is = to (row - 1)
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1; //columnLength is the user's column, which begins at A and is equated to 1; realColumn begins at 0 and is therefore = to (column - 1).
		if (this.data[realColumn][realRow] == null) { //Step #1: If the value is null, return 0.0 
			double returnZero = 0;
			return returnZero;
		} else {
			Cell cell = new FormulaCell (String.valueOf(this.data[realColumn][realRow]), this);
			return this.data[realColumn][realRow].getNumericValue();
		}
	}
	public double getValue(String cell) {		
		char userColumnLabel = cell.charAt(0);
		int userRowLabel =  Integer.parseInt ((cell.substring(1))); //Even if the rowLabel is larger than >9
		int realRow = userRowLabel - 1; 
		int columnLength = 0;
		for (char counter = 'A'; counter <= userColumnLabel; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		if (this.data[realColumn][realRow] == null) { //Step #1: If the value is null, change it to 0.0
			double returnZero = 0;
			return returnZero;
		} else {
			Cell freshCell = new FormulaCell (String.valueOf(this.data[realColumn][realRow]), this);
			return this.data[realColumn][realRow].getNumericValue();
		}
	}
	public double evaluateFormula(char column, int row) { //return the numeric value produced by evaluating the formula stored in the given cell 
		int realRow = row - 1; 
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		String checkCell = String.valueOf(this.data[realColumn][realRow]);
		if (checkCell.length () < 7) { //Make sure that there is an equation - we are not responsible for equations like (C4 + 1)
			throw new IllegalStateException (); //throws if the cell does not contain a formula, throw an IllegalStateException
		}
		if (checkCell == null){
			throw new IllegalStateException (); //throws if the cell does not contain a formula, throw an IllegalStateException
		}
		Cell cell = new FormulaCell (String.valueOf(this.data[realColumn][realRow]), this); //Refer to the instance of the CellSpreadSheet class
		return this.data[realColumn][realRow].getNumericValue();
	}
	public Cell getCell (char column, int row) {
		int realRow = row - 1; 
		int columnLength = 0;
		for (char counter = 'A'; counter <= column; counter++) {
			columnLength++;
		}
		int realColumn = columnLength - 1;
		return this.data[realColumn][realRow];
	}
}